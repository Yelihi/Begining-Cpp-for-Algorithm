// 동적 프로그래밍.. 아직 못풀었던 개념
// 개념은 같았지만, 시간복잡도를 따져야 하기에 dp 가 필요하다
function solution(land) {
  /**
   * 주어진 행렬에 길이를 계산하여, 총 얼마나 반복을 돌릴지 결정한다.
   * */
  const n = land.length;
  /**
   * dp 는 [[0,0,0,0],[0,0,0,0],[0,0,0,0]...] 으로 우선 생성해주자
   * 이제 여기서 각 행의 최대값을 저장할 예정이다.
   */
  const dp = Array.from(Array(n), () => Array(4).fill(0)); // dp 배열 초기화

  // 첫 번째 행의 값으로 dp 배열 초기화
  for (let i = 0; i < 4; i++) {
    dp[0][i] = land[0][i];
  }
  /**
   * 여기까지 오면 dp 는 (예시로서) [[1,2,3,5],[0,0,0,0]...] 이렇게 구성이 된다
   * 이제 2번째 행(i = 1) 부터 값을 저장시켜주어야 한다.
   */

  // 두 번째 행부터 dp 배열 갱신
  /**
   * 우선 두번째 행부터 n번째 행까지 순회를 돌아줄 것이다
   * 이후 첫번째 열부터 4번째 열까지 중첩 순회를 돌아준다
   * 같은 열로는 이동할 수 없으니 이의 체크를 위해 k 를 통해서 순회를 돌아준다
   */
  for (let i = 1; i < n; i++) {
    for (let j = 0; j < 4; j++) {
      for (let k = 0; k < 4; k++) {
        if (j !== k) {
          // 같은 열을 연속해서 밟을 수 없는 규칙
          /**
           * 예를 들어 dp[1][0] 의 경우 land[1][0] 을 밟을때의 최대값이다.
           * 즉, dp[1][0] 은 그 전까지의 루트중에서 가장 최대값이 land[1][0] 을 밟을 때의 수치다
           * 그렇기에, dp[0][1],dp[0][2].. 와 land[1][0] 을 더한것 중 최대값을 저장한다
           */
          dp[i][j] = Math.max(dp[i][j], dp[i - 1][k] + land[i][j]);
        }
      }
    }
  }

  // 마지막 행의 최대값을 반환
  return Math.max(...dp[n - 1]);
}
