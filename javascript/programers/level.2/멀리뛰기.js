/**
 * 역시나 dp를 활용한 문제
 * 처음에는 재귀를 통해 해결하려 했으나, 조건상 런타임 아웃이 발생한다.
 * 아무래도 2가지의 재귀의 합을 리턴하기에 너무 복잡도가 커진다.
 */

function solution(n) {
  // 우선 dp 배열을 생성한다
  let dp = Array(n).fill(0);
  // 초기값을 저장해주자. 1칸은 1가지경우, 2칸은 2가지 경우가 있다.
  dp[0] = 1;
  dp[1] = 2;
  /**
   * 예를 들어 4번째까지의 경우의 수를 생각해보면
   * 3번째까지의 경우의 수에서 1칸을 움직이면 4번째의 경우의 수가 되니 일단 하나의 방향이며
   * 2번째까지의 이동 경우의 수에서 2칸을 움직이면 4번째 칸이니
   * 결국 3번째까지의 경우의 수 + 2번째까지의 경우의 수가 4번째까지 가는 경우의 수가 된다.
   */
  for (let i = 2; i < n; i++) {
    dp[i] = (dp[i - 1] + dp[i - 2]) % 1234567; // 런타임아웃때문에 미리 나눠준다
  }
  // 마지막 원소의 값을 리턴해준다
  let answer = dp[n - 1];
  return answer;
}
